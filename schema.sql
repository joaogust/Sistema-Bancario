-- ==========================================================
-- 1. ESTRUTURA BÁSICA (Tabelas)
-- ==========================================================

CREATE TABLE profissoes (
    id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    nome VARCHAR(100) NOT NULL UNIQUE
);

CREATE TABLE clientes (
    id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    cpf VARCHAR(11) UNIQUE NOT NULL,
    rg VARCHAR(9) UNIQUE NOT NULL,
    nome VARCHAR(150) NOT NULL,
    data_nascimento DATE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    salario DECIMAL(12, 2) NOT NULL DEFAULT 0.00,
    vl_patrimonio DECIMAL(15, 2) NOT NULL DEFAULT 0.00,
    id_profissao INT NOT NULL,
    senha_hash VARCHAR(255) NOT NULL,
    CONSTRAINT fk_cliente_profissao FOREIGN KEY (id_profissao) REFERENCES profissoes(id)
);

CREATE TABLE telefones (
    id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    numero VARCHAR(15) NOT NULL,
    tipo VARCHAR(15) NOT NULL,
    id_cliente INT NOT NULL,
    CONSTRAINT fk_telefone_cliente FOREIGN KEY (id_cliente) REFERENCES clientes(id),
    CONSTRAINT ck_tipo_telefone CHECK(tipo IN('residencial', 'celular'))
);

CREATE TABLE enderecos (
    id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    rua VARCHAR(255) NOT NULL,
    numero VARCHAR(20) NOT NULL,
    bairro VARCHAR(100) NOT NULL,
    cidade VARCHAR(100) NOT NULL,
    estado CHAR(2) NOT NULL,
    cep VARCHAR(8) NOT NULL,
    complemento VARCHAR(100),
    id_cliente INT NOT NULL,
    CONSTRAINT fk_endereco_cliente FOREIGN KEY (id_cliente) REFERENCES clientes(id)
);

CREATE TABLE contas (
    id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    agencia VARCHAR(4) NOT NULL,
    numero_conta VARCHAR(20) UNIQUE NOT NULL,
    tipo VARCHAR(20) NOT NULL,
    saldo DECIMAL(15, 2) NOT NULL DEFAULT 0.00,
    data_hora_abertura TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP, -- Usar Timezone
    data_hora_fechamento TIMESTAMPTZ,
    estado VARCHAR(20) NOT NULL,
    id_cliente INT NOT NULL,
    CONSTRAINT fk_conta_cliente FOREIGN KEY (id_cliente) REFERENCES clientes(id),
    CONSTRAINT ck_estado_conta CHECK(estado IN('ativa', 'bloqueada', 'encerrada'))
);

CREATE TABLE chaves_pix (
    id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    chave VARCHAR(100) UNIQUE NOT NULL,
    tipo VARCHAR(20) NOT NULL,
    id_conta INT NOT NULL,
    CONSTRAINT fk_chave_pix_conta FOREIGN KEY (id_conta) REFERENCES contas(id),
    CONSTRAINT ck_tipo_chave_pix CHECK(tipo IN('email', 'telefone', 'aleatoria', 'cpf'))
);

CREATE TABLE movimentacoes (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    valor DECIMAL(15, 2) NOT NULL,
    data_hora TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    tipo VARCHAR(30) NOT NULL,
    id_conta INT NOT NULL,
    chave_destino VARCHAR(100),
    num_conta_destino VARCHAR(20),
    agencia_destino VARCHAR(20),
    tipo_conta_destino VARCHAR(20),
    instituicao_destino VARCHAR(100),
    nome_destino VARCHAR(150),
    cpf_cnpj_destino VARCHAR(14),
    CONSTRAINT fk_movimentacao_conta FOREIGN KEY (id_conta) REFERENCES contas(id),
    CONSTRAINT ck_tipo_movimentacao CHECK(tipo IN(
        'PIX ENVIADO', 'PIX RECEBIDO', 
        'TED ENVIADA', 'DEPOSITO', 'SAQUE',
        'TRANSFERENCIA_ENVIADA', 'TRANSFERENCIA_RECEBIDA'
    ))
);

-- ==========================================================
-- 2. LOG AUDITORIA
-- ==========================================================

CREATE TABLE log_auditoria (
    id_log BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    data_hora TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    usuario_acao VARCHAR(50) DEFAULT CURRENT_USER,
    tipo_acao CHAR(1) NOT NULL,
    nome_tabela VARCHAR(50) NOT NULL,
    id_registro_afetado INT,
    dados_antigos JSONB, 
    dados_novos JSONB 
);

CREATE OR REPLACE FUNCTION auditar_alteracao_cliente()
RETURNS TRIGGER AS $$
BEGIN
    IF (TG_OP = 'INSERT') THEN
        INSERT INTO log_auditoria (tipo_acao, nome_tabela, id_registro_afetado, dados_novos)
        VALUES ('I', 'clientes', NEW.id, row_to_json(NEW));
        RETURN NEW;
    ELSIF (TG_OP = 'UPDATE') THEN
        INSERT INTO log_auditoria (tipo_acao, nome_tabela, id_registro_afetado, dados_antigos, dados_novos)
        VALUES ('U', 'clientes', NEW.id, row_to_json(OLD), row_to_json(NEW));
        RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        INSERT INTO log_auditoria (tipo_acao, nome_tabela, id_registro_afetado, dados_antigos)
        VALUES ('D', 'clientes', OLD.id, row_to_json(OLD));
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tr_auditar_clientes
AFTER INSERT OR UPDATE OR DELETE ON clientes
FOR EACH ROW
EXECUTE FUNCTION auditar_alteracao_cliente();

-- ==========================================================
-- 3. VIEWS
-- ==========================================================

CREATE VIEW view_extrato_cliente AS
SELECT
    m.id AS id_movimentacao,
    m.id_conta,
    m.data_hora,
    m.valor,
    m.tipo,
    CASE
        WHEN m.tipo IN ('DEPOSITO', 'PIX RECEBIDO', 'TRANSFERENCIA_RECEBIDA') THEN 'ENTRADA'
        ELSE 'SAÍDA'
    END AS fluxo,
    CASE
        WHEN m.tipo = 'PIX ENVIADO' THEN CONCAT('PIX para ', COALESCE(m.nome_destino, m.chave_destino))
        WHEN m.tipo = 'PIX RECEBIDO' THEN 'PIX Recebido'
        WHEN m.tipo = 'TRANSFERENCIA_ENVIADA' THEN CONCAT('Transferência para ', m.nome_destino)
        WHEN m.tipo = 'TRANSFERENCIA_RECEBIDA' THEN CONCAT('Transferência de ', m.nome_destino)
        WHEN m.tipo = 'DEPOSITO' THEN 'Depósito em Conta'
        WHEN m.tipo = 'SAQUE' THEN 'Saque em Terminal'
        ELSE m.tipo
    END AS descricao_formatada
FROM movimentacoes m
ORDER BY m.data_hora DESC;

CREATE VIEW view_clientes_gerencial AS
SELECT
    c.id AS id_cliente,
    c.nome,
    c.cpf,
    c.email,
    p.nome AS profissao,
    co.numero_conta,
    co.agencia,
    co.saldo,
    co.estado AS estado_conta,
    e.cidade,
    e.estado AS estado_residencia
FROM clientes c
JOIN profissoes p ON c.id_profissao = p.id
JOIN contas co ON c.id = co.id_cliente
LEFT JOIN enderecos e ON c.id = e.id_cliente;

-- ==========================================================
-- 4. PROCEDURES
-- ==========================================================

-- Procedure: SAQUE
CREATE OR REPLACE FUNCTION realizar_saque(
    p_id_conta INT,
    p_valor NUMERIC
)
RETURNS BOOLEAN AS $$
DECLARE
    v_saldo_atual NUMERIC;
BEGIN
    IF p_valor <= 0 THEN
        RAISE EXCEPTION 'Valor inválido.';
    END IF;

    SELECT saldo INTO v_saldo_atual FROM contas WHERE id = p_id_conta FOR UPDATE;

    IF NOT FOUND THEN RAISE EXCEPTION 'Conta não encontrada.'; END IF;
    IF v_saldo_atual < p_valor THEN RAISE EXCEPTION 'Saldo insuficiente.'; END IF;

    UPDATE contas SET saldo = saldo - p_valor WHERE id = p_id_conta;

    INSERT INTO movimentacoes (valor, tipo, id_conta)
    VALUES (p_valor, 'SAQUE', p_id_conta);

    RETURN TRUE;
END;
$$ LANGUAGE plpgsql;

-- Procedure: TRANSFERÊNCIA INTERNA 
CREATE OR REPLACE FUNCTION realizar_transferencia_interna(
    p_id_conta_origem INT,
    p_id_conta_destino INT,
    p_valor NUMERIC
)
RETURNS BOOLEAN AS $$
DECLARE
    v_saldo_origem NUMERIC;
    v_nome_origem VARCHAR;
    v_nome_destino VARCHAR;
BEGIN
    IF p_valor <= 0 THEN RAISE EXCEPTION 'Valor inválido.'; END IF;
    IF p_id_conta_origem = p_id_conta_destino THEN RAISE EXCEPTION 'Contas iguais.'; END IF;

    SELECT saldo, (SELECT nome FROM clientes WHERE id = contas.id_cliente) 
    INTO v_saldo_origem, v_nome_origem
    FROM contas WHERE id = p_id_conta_origem FOR UPDATE;

    IF v_saldo_origem < p_valor THEN RAISE EXCEPTION 'Saldo insuficiente.'; END IF;

    SELECT (SELECT nome FROM clientes WHERE id = contas.id_cliente)
    INTO v_nome_destino
    FROM contas WHERE id = p_id_conta_destino FOR UPDATE;
    
    IF v_nome_destino IS NULL THEN RAISE EXCEPTION 'Conta destino não encontrada.'; END IF;

    UPDATE contas SET saldo = saldo - p_valor WHERE id = p_id_conta_origem;
    INSERT INTO movimentacoes (valor, tipo, id_conta, nome_destino)
    VALUES (p_valor, 'TRANSFERENCIA_ENVIADA', p_id_conta_origem, v_nome_destino);

    UPDATE contas SET saldo = saldo + p_valor WHERE id = p_id_conta_destino;
    INSERT INTO movimentacoes (valor, tipo, id_conta, nome_destino)
    VALUES (p_valor, 'TRANSFERENCIA_RECEBIDA', p_id_conta_destino, v_nome_origem);

    RETURN TRUE;
END;
$$ LANGUAGE plpgsql;